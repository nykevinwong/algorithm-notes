#### import-learning-steps.txt
(1) must know the optimized approach with lowest time complexity.
(2) if the optimized approach is difficult to understand, pick the easier code with reasonable time complexity.
(3) must see if the brute force has connection to optimzed approach. this help you to quickly recognize the optimized approach when just seeing the brute force code.
#### July_01_2019.txt
121. Best Time to Buy and Sell Stock (Easy)
Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (i.e., buy one and sell one share of the stock), design an algorithm to find the maximum profit.
Note that you cannot sell a stock before you buy one.
Input: [7,1,5,3,6,4] Output: 5
Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
             Not 7-1 = 6, as selling price needs to be larger than buying price.

    public int maxProfit_k_1(int[] prices) {
        // on ith day, i don't have a stock and i can do at most k transaction.
        // dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1]+prices[i]);
        // dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0]-prices[i])
        // dp[-1][k][0] = 0 // 沒開始前，沒持有股票時的最大獲利值。
        // dp[-1][k][1] = -infiity // 沒開始前，是不可能持有股票。這狀態不可能存在。
        // dp[i][0][0] = 0  // 沒法交易時的最大獲利值。
        // dp[i][0][1] = -infiity // 沒法交易時，是不可能持有股票。這狀態不可能存在。
        // 
        if(prices==null || prices.length==0) return 0;
        
        int n = prices.length;        
        int[][] dp = new int[n][2];
        
        for (int i = 0; i < n; i++) {
            if (i - 1 == -1) { 
                // calculate when i = 0
                dp[i][0] = 0;
                // 解释：
                //   dp[i][0] 
                // = max(dp[-1][0], dp[-1][1] + prices[i])
                // = max(0, -infinity + prices[i]) = 0
                dp[i][1] = -prices[i];
                //解释：
                //   dp[i][1] 
                // = max(dp[-1][1], dp[-1][0] - prices[i])
                // = max(-infinity, 0 - prices[i]) 
                // = -prices[i]
                continue;
            }
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
        }
        return dp[n- 1][0];
    }
    
    public int maxProfit_k(int[] prices) {
        if(prices==null || prices.length==0) return 0;
        
        int n = prices.length;        
        int dp_i_0 = 0,  dp_i_1 = Integer.MIN_VALUE;
        
        for (int i = 0; i < n; i++) {
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, -prices[i]);
        }
        return dp_i_0;
    }

122. Best Time to Buy and Sell Stock II (Easy)
Say you have an array for which the ith element is the price of a given stock on day i.
Design an algorithm to find the maximum profit. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).

// when k = +infitiy transaction
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length==0) return 0;
        
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        
        for(int i=0;i<n;i++)
        {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1+prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
        }
        
        return dp_i_0;
    }

714. Best Time to Buy and Sell Stock with Transaction Fee
Medium
 // (1) k = +infiity transactions, (2) transactino fee
    public int maxProfit(int[] prices, int fee) {
        if(prices==null || prices.length==0) return 0;
        int n = prices.length;        
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        
        for(int i=0;i<n;i++)
        {
            int temp = dp_i_0;
            dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);            
        }
        
        return dp_i_0;
    }

309. Best Time to Buy and Sell Stock with Cooldown (Medium)

// +k infiity with Cooldown
    public int maxProfit(int[] prices) {
        if(prices==null || prices.length==0) return 0;
        int n = prices.length;
        int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
        int dp_i2_0 = 0;
        
        for(int i=0;i<n;i++)
        {
            int prev = dp_i_0;
            dp_i_0 = Math.max( dp_i_0, dp_i_1 + prices[i]);
            dp_i_1 = Math.max( dp_i_1, dp_i2_0 - prices[i]);
            dp_i2_0 = prev;
        }
        
        return dp_i_0;
    }
#### July_03_2019.txt
76. Minimum Window Substring (Hard) 最小覆盖子串
Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。
Example: Input: S = "ADOBECODEBANC", T = "ABC", Output: "BANC"
Note: If there is no such window in S that covers all characters in T, return the empty string "". 
如果 S 中不存这样的子串，则返回空字符串 ""。
If there is such window, you are guaranteed that there will always be only one unique minimum window in S.
如果 S 中存在这样的子串，我们保证它是唯一的答案。

    public String minWindow(String s, String t) {
        int minStart = 0, minEnd = Integer.MAX_VALUE;
        HashMap<Character,Integer> m = new HashMap<>();

        for(int i=0;i < t.length();i++)
        {
            char c = t.charAt(i);
            m.put(c, m.getOrDefault(c,0)+1);  
        }

        int start = 0, end = 0;
        int counter = m.size();

        while(end < s.length())
        {
            char eChar = s.charAt(end);     
            
            if(m.containsKey(eChar))
            {
                m.put(eChar,m.get(eChar)-1);
                if(m.get(eChar)==0) counter--;
            }

            while(counter==0) // when the interval contains the valid string
            {
                // shrink the interval
                char sChar = s.charAt(start);     
                if(m.containsKey(sChar))
                {
                    m.put(sChar,m.get(sChar)+1);
                    if(m.get(sChar)==1) counter++;
                }
                
                if( (end-start) < (minEnd-minStart))
                {
                    minStart = start;
                    minEnd = end;
                }

                start++;
            }

            end++;
        }

        return (minEnd==Integer.MAX_VALUE) ? "":s.substring(minStart, minEnd+1);
    }

438. Find All Anagrams in a String (Easy) 找到字符串中所有字母异位词
Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。
Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。
The order of output does not matter. 不考虑答案输出的顺序。

Example 1: Input: s: "cbaebabacd" p: "abc" ,Output: [0, 6]
字母异位词指字母相同，但排列不同的字符串。

    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<Integer>();
        if(s==null || p ==null) return res;
        
        int start = 0, end = 0;
        int len = 0, pLen = p.length();
        HashMap<Character,Integer> m = new HashMap<>();
        
        for(int i=0;i<p.length();i++)
        {
            char c = p.charAt(i);
            m.put(c,m.getOrDefault(c,0)+1);
        }
        
        int counter = m.size();
        
        while(end < s.length())
        {
            char eChar = s.charAt(end);
            
            if(m.containsKey(eChar))
            {
                m.put(eChar,m.get(eChar)-1);
                if(m.get(eChar)==0) counter--;
            }
            
            end++;            
            
            if( (end-start)==pLen)
            {
                if(counter==0) res.add(start);
                char sChar = s.charAt(start);

                if(m.containsKey(sChar))
                {
                    m.put(sChar,m.get(sChar)+1);
                    if(m.get(sChar)==1) counter++;
                }
                
                start++;               
            }
            
        }
        
        return res;
    }

#### July_04_2019.txt
3. Longest Substring Without Repeating Characters (Medium)
Given a string, find the length of the longest substring without repeating characters.
Example 1: Input: "abcabcbb", Output: 3, Explanation: The answer is "abc", with the length of 3. 
Example 2: Input: "bbbbb", Output: 1, Explanation: The answer is "b", with the length of 1.
示例 3: 输入: "pwwkew", 输出: 3, 解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

    public int lengthOfLongestSubstring(String s) {
        if(s==null || s.length()==0) return 0;
        int start = 0, end = 0;
        int maxStart = 0, maxEnd = Integer.MIN_VALUE;
        int[] m = new int[256];
        
        while(end < s.length())
        {
            char eChar = s.charAt(end);
            m[eChar]++;
            
            while(m[eChar]==2)
            {
                char sChar = s.charAt(start);
                m[sChar]--;
                start++;
            }            
            
            if((end-start) > (maxEnd-maxStart))
            {
                maxEnd = end;
                maxStart = start;
            }
            
            end++; // the placement of end position affect the result to plus 1 or not.            
        }
        
        return (maxEnd==Integer.MIN_VALUE) ? 0:  (maxEnd-maxStart+1);       
    }

30. Substring with Concatenation of All Words (Hard) 串联所有单词的子串
You are given a string, s, and a list of words, words, that are all of the same length.  给定一个字符串 s 和一些长度相同的单词 words。
Find all starting indices of substring(s) in s that is a concatenation of each word in words exactly once and without any intervening characters.
找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。
Example 1: Input: s = "barfoothefoobarman", words = ["foo","bar"] Output: [0,9]
Explanation: Substrings starting at index 0 and 9 are "barfoor" and "foobar" respectively. The output order does not matter, returning [9,0] is fine too.
Example 2: Input: s = "wordgoodgoodgoodbestword", words = ["word","good","best","word"], Output: []

    public List<Integer> findSubstring(String s, String[] words) {
        List<Integer> res = new ArrayList<Integer>();
        if(s==null || s.length()==0 || words == null || words.length ==0 ) return res;

        HashMap<String, Integer> m = new HashMap<>();
        int wordsLen = 0;

        for(String word: words)
        {
            wordsLen += word.length();
            m.put(word, m.getOrDefault(word, 0)+1);
        }
        
        if(s.length() < wordsLen) return res;

        HashMap<String, Integer> tmp = new HashMap<>();

        for(int i=0; i < s.length() - wordsLen + 1;i++)
        {
            int matched= 0; int start = i;
            tmp.clear();

            int fixedVocabularyLen = words[0].length();            
            while(matched < words.length) 
            {
                String w = s.substring(start, start + fixedVocabularyLen);              
                
                if(!m.containsKey(w)) break; // 目前字詞不能匹配任何在words的字詞
                
                tmp.put(w, tmp.getOrDefault(w,0)+1);
                if(tmp.get(w) > m.get(w)) break; // 超過同一單詞在words中的出現次數 
                
                matched++; // matched
                start += w.length(); // 調整start位置以檢查下一個字詞
                // 如果words中的字詞長度不一，就需要這行及 fixedVocabularyLen.
                if(matched < words.length) fixedVocabularyLen = words[matched].length();
            }
            
            // 匹配數與words字詞數相等，條件符合，加入答案表
            if(matched==words.length) res.add(i);
        }
        
        return res;
    }
#### July_06_2019.txt
159. Longest Substring with At Most Two Distinct Characters (Hard) 至多包含两个不同字符的最长子串
Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters.
Example 1: Input: "eceba", Output: 3, Explanation: t is "ece" which its length is 3.

    public int lengthOfLongestSubstringTwoDistinct(String s) 
    {
        if(s==null || s.length()==0) return 0;
        
        HashMap<Character,Integer> m = new HashMap<>();
        int start = 0 , end = 0;
        int maxStart = 0, maxEnd = Integer.MIN_VALUE;
        int nonZeroCount = 0; // HashMap.size() is the size of keys. not size when keys == 0
        
        while(end < s.length())
        {
            char eChar = s.charAt(end);            
            m.put(eChar, m.getOrDefault(eChar,0)+1); // m[eChar]++
            
            if(m.get(eChar)==1) nonZeroCount++;

            while(nonZeroCount==3)
            {
                char sChar = s.charAt(start);            
                m.put(sChar, m.get(sChar)-1); // m[sChar]--
                if(m.get(sChar)==0) nonZeroCount--;
                start++;
            }
                
            if(nonZeroCount<=2) // <= because at most 2 means it includes when it's 0 or 1.
            {
                if((end-start) > (maxEnd-maxStart))
                {
                    maxStart = start;
                    maxEnd = end;
                }

            end++;
        }
                
        return maxEnd==Integer.MIN_VALUE ? 0: (maxEnd-maxStart+1);
    }

340. Longest Substring with At Most K Distinct Characters (Hard)
Given a string, find the length of the longest substring T that contains at most k distinct characters.
Example 1: Input: s = "eceba", k = 2, Output: 3, Explanation: T is "ece" which its length is 3.

    public int lengthOfLongestSubstringKDistinct(String s, int k) 
    {
        if(s==null || s.length()==0) return 0;
        
        HashMap<Character,Integer> m = new HashMap<>();
        int start = 0 , end = 0;
        int maxStart = 0, maxEnd = Integer.MIN_VALUE;
        int nonZeroCount = 0; // HashMap.size() is the size of keys. not size when keys == 0
        
        while(end < s.length())
        {
            char eChar = s.charAt(end);            
            m.put(eChar, m.getOrDefault(eChar,0)+1); // m[eChar]++
            
            if(m.get(eChar)==1) nonZeroCount++;

            while(nonZeroCount==k+1)
            {
                char sChar = s.charAt(start);            
                m.put(sChar, m.get(sChar)-1); // m[sChar]--
                if(m.get(sChar)==0) nonZeroCount--;
                start++;
            }
                
            if(nonZeroCount<=k) // <= because at most 2 means it includes when it's 0 or 1.
            {
                if((end-start) > (maxEnd-maxStart))
                {
                    maxStart = start;
                    maxEnd = end;
                }
            
            end++;
        }
                
        return maxEnd==Integer.MIN_VALUE ? 0: (maxEnd-maxStart+1);
    }

1100. Find K-Length Substrings With No Repeated Characters (Medium)
Given a string S, return the number of substrings of length K with no repeated characters.
Example 1: Input: S = "havefunonleetcode", K = 5, Output: 6
Explanation:  There are 6 substrings they are : 'havef','avefu','vefun','efuno','etcod','tcode'.
Example 2: Input: S = "home", K = 5, Output: 0 
Explanation:  Notice K can be larger than the length of S. In this case is not possible to find any substring.

    public int numKLenSubstrNoRepeats(String S, int K) {
        if(S==null) return 0;
        if(S.length() < K) return 0;
        int start = 0, end = 0;        
        int[] m = new int[256];
        int res = 0;
        
        while(end < S.length())
        {
            char eChar = S.charAt(end);
            m[eChar]++;
            
            while(m[eChar]==2) // if the interval is invalid
            {
                char sChar = S.charAt(start);
                m[sChar]--;
                start++;
            }
            
            int len = end-start+1;            
            if(len==K)  // valid interval
            { 
                res++; // add answer count
                
                // move the window with the fixed size
                char sChar = S.charAt(start); 
                m[sChar]--;
                start++;                                
            }            
            
            end++;
        }
        
        return res;        
    }

567. Permutation in String (Medium)
Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.
Example 1: Input: s1 = "ab" s2 = "eidbaooo" ,Output: True
Explanation: s2 contains one permutation of s1 ("ba").

        public boolean checkInclusion(String s1, String s2) {
        if(s1==null || s2 == null) return false;
        if(s1.length() > s2.length()) return false;
        
        HashMap<Character,Integer> m = new HashMap<>();
        HashMap<Character,Integer> tmp = new HashMap<>();
        
        for(int i=0;i<s1.length();i++)
        {
            char c = s1.charAt(i);
            m.put(c, m.getOrDefault(c, 0)+1);
        }
        
        int start = 0, end = 0;
        
        while(end < s2.length())
        {
            char eChar = s2.charAt(end);
            tmp.put(eChar, tmp.getOrDefault(eChar, 0)+1);
            
            int len = end-start +1;
            if(len == s1.length())
            {
                // this is a valid answer
                if(tmp.equals(m)) return true;
                
                char sChar = s2.charAt(start);                
                tmp.put(sChar, tmp.getOrDefault(sChar, 0)-1);
                
                if(tmp.get(sChar)==0) tmp.remove(sChar);

                start++;                
            }
            end++;
        }

        return false;
    }
#### July_07_2019.txt
class Solution {
    public int[] crossMaxSum(int[] nums, int l, int m, int r)
    {
        int leftSum = 0;
        int leftMax = Integer.MIN_VALUE;
        int leftIndex = -1;
        for(int i=m;i>=l;i--)
        {
            leftSum+= nums[i];
            if(leftSum > leftMax)
            {
                leftMax = leftSum;
                leftIndex = i;
            }
        
        int rightSum = 0;
        int rightMax = Integer.MIN_VALUE;
        int rightIndex = -1;
        for(int i=m+1;i<=r;i++)
        {
            rightSum+= nums[i];
            if(rightSum > rightMax)
            {
                rightMax = rightSum;
                rightIndex = i;
            }
        
        return new int[]{leftIndex,rightIndex, leftMax + rightMax};
    }
    
    public int maxSubArraySum(int[] nums, int l, int r)
    {
        if(l==r)
            return nums[l];
        
        int m = l+(r-l)/2;
        int leftSum = maxSubArraySum(nums, l, m);
        int rightSum = maxSubArraySum(nums, m+1, r);
        int crossSum = crossMaxSum(nums, l, m, r)[2];
        
        int max = Math.max(leftSum,rightSum);
        
        return Math.max(crossSum, max);
    }
    
    public int maxSubArray2(int[] nums) {
        if(nums==null) return 0;
        return maxSubArraySum(nums, 0, nums.length-1);
    }
    
    // Kadane's algorithm. it won't work when an array fille with negative values
    public int maxSubArray_Kadane(int[] nums) {
        if(nums==null) return 0;

        int maxSoFar = Integer.MIN_VALUE;
        int maxEndingHere = 0;
        for(int i=0;i<nums.length;i++)
        {
            maxEndingHere+= nums[i];
            maxEndingHere= Math.max(maxEndingHere,0);
            maxSoFar= Math.max(maxSoFar,maxEndingHere);        
        }
        
        return maxSoFar;
    }
    
    // dyanmic programming approach
    public int maxSubArray(int[] nums) {
        if(nums==null) return 0;
        int[] dp = new int[nums.length];        
        int max = Integer.MIN_VALUE;
        
        //dp[i] = 從0到目前i位置的每個包含i位置的子數組總和的最大值
        //dp[i] = max(sum(i,i),sum(i,i-1),sum(i,0))
        //如 dp[3] = max(sum(3,3),sum(3,2),sum(3,1),sum(3,0))
        //如 dp[2] = max(sum(2,2),sum(2,1),sum(2,0))
        // 暴力解即是一次找出所有(0,0)至(n-1,n-1)區間之各個子數組之和的最大值
        // 此動態規劃解是求出每個(i,0)至(i,i)區間之各個子數組之和的最大值，並存入dp[i]
        // 因此，得到各個到目前數組索引的總和的最大值，必須再對所有最大值找出總最大值就是答案。
        for(int i=0;i<nums.length;i++)
        {
            if(i-1==-1) dp[i]=nums[i];
            else dp[i]=Math.max(dp[i-1]+nums[i], nums[i]);
            
            max = Math.max(dp[i], max);
        }

        return max;
    }
    
}
#### July_11_2019.txt
75. Sort Colors (Medium)
Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.
Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Example:
Input: [2,0,2,1,1,0]
Output: [0,0,1,1,2,2]

    public void sortColors(int[] nums) {
        // Counting sort is also the solution, but its space complexity sucks.
        int left, right = nums.length-1;
        int reader;
        left=reader=0;
        
        while(reader <= right)
        {
            if(nums[reader]==0)
                swap(nums,left++,reader++);
            else if(nums[reader]==1)
                reader++;
            else if(nums[reader]==2)
                swap(nums,reader,right--);
        }

    }
    
    public void swap(int[] nums, int a,int b)
    {
        int temp = nums[a];
        nums[a]= nums[b];
        nums[b] =temp;
    }

49. Group Anagrams (Medium)
Given an array of strings, group anagrams together.
Example:
Input: ["eat", "tea", "tan", "ate", "nat", "bat"],
Output:[  ["ate","eat","tea"],  ["nat","tan"],  ["bat"]]
Note: All inputs will be in lowercase. The order of your output does not matter.
    
    // O(N*k*log*(k)) , k = max length of a string in strs. sorting cost k*log(k) times
    public List<List<String>> groupAnagrams(String[] strs) {
        HashMap<String, List> ans = new HashMap<>();
        
        for(String s:strs)
        {
            char[] arr = s.toCharArray();
            Arrays.sort(arr);
            String key = String.valueOf(arr);
            if(!ans.containsKey(key)) ans.put(key, new ArrayList());
            ans.get(key).add(s);
        }
        
        return new ArrayList(ans.values());
    }

    // O(kN) 
    public List<List<String>> groupAnagrams(String[] strs) {
        if(strs==null || strs.length==0) return new ArrayList();
        
        Map<String, List> m = new HashMap<>();
        Map<String, List> ans = new HashMap<>();
        int[] count = new int[26];
        
        for(String s: strs)
        {
            Arrays.fill(count,0);
            for(char c: s.toCharArray()) count[c-'a']++;
            
            StringBuilder sb = new StringBuilder("");            
            for(int i=0; i < 26; i++)
            {
                sb.append("#");
                sb.append(count[i]);
            }
            
            String key = sb.toString();
            if(!ans.containsKey(key)) ans.put(key, new ArrayList());
            ans.get(key).add(s);            
        }
        
        return new ArrayList(ans.values());        
    }

36. Valid Sudoku (Medium)
Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:
Each row must contain the digits 1-9 without repetition.
Each column must contain the digits 1-9 without repetition.
Each of the 9 3x3 sub-boxes of the grid must contain the digits 1-9 without repetition.

    public boolean isValidSudoku(char[][] board) {
        HashMap<Integer,Integer>[] rows = new HashMap[9]; 
        HashMap<Integer,Integer>[] cols = new HashMap[9]; 
        HashMap<Integer,Integer>[] boxes = new HashMap[9]; 
        
        for(int i=0;i<9;i++)
        {
            rows[i] = new HashMap<Integer,Integer>();
            cols[i] = new HashMap<Integer,Integer>();
            boxes[i] = new HashMap<Integer,Integer>();            
        }
        
        for(int y=0;y<9;y++)
        {
            for(int x=0;x<9;x++)
            {
                char c = board[y][x];
                if(c!='.')
                {
                    int number = (int)(c-'0');
                    int boxID = (y/3)*3+ (x/3); //calculate grid index
                    int key = number;
                    rows[y].put(key, rows[y].getOrDefault(key,0)+1);
                    cols[x].put(key, cols[x].getOrDefault(key,0)+1);
                    boxes[boxID].put(key, boxes[boxID].getOrDefault(key,0)+1);
                    
                    if(rows[y].get(key) > 1 || cols[x].get(key) > 1 || boxes[boxID].get(key) > 1) 
                        return false;
                }                
        
        return true;
    }

138. Copy List with Random Pointer (Medium)
A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

// Time: O(N), Space:O(N)
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node dummy = new Node(0,null,null);
        Node cur = dummy; // pay attention here.
        Node old = head;
        HashMap<Node,Node> m = new HashMap<>();
        
        while(old!=null)
        {
            Node node = new Node(old.val, null, null);  // make a copy       
            m.put(old, node); 
            cur.next = node; // add to new list           
            cur = cur.next; // move next on new list
            old = old.next; // move next on old list
        }

        cur = dummy.next; // pay attention here.
        old = head;
        while(old!=null)
        {
            if(old.random!=null)
                cur.random = m.get(old.random);
            cur = cur.next;
            old = old.next;
        }        
        
        return dummy.next;        
    }

// Time: O(N), Space:O(1)
    public Node copyRandomList(Node head) {
        if(head==null) return null;
        Node old = head;
        HashMap<Node,Node> m = new HashMap<>();
        
        // insert new copy node into new list
        while(old!=null)
        {
            Node copy = new Node(old.val, null, null);  // make a copy       
            // insert into old list
            copy.next = old.next;
            old.next = copy;
            
            // move to next
            old = old.next.next; // or p = copy.next
        }
        
        // copy random node for new one
        old = head;
        while(old!=null)
        {
            Node copy = old.next;
            if(old.random!=null) // the position of new random node is next position of old one 
                copy.random = old.random.next;
            old=old.next.next;            
        }
        
        // split into two list
        old = head;
        Node newHead = head.next;
        while(old!=null)
        {
            Node copy = old.next;
            old.next = copy.next;
            if(copy.next!=null)
                copy.next = copy.next.next;
            old=old.next;            
        }

        return newHead;        
    }

#### June_01_2019.txt
Substrings. // print all substrings of a given string (the problem is given by Leo)
import java.util.*;
class Substrings
{
    public static void substrings(char[] str, List<String> res, StringBuilder sb, int start, int end)
    {        
        if(start>= str.length || end>=str.length) return; // skip to prevent from app crash.

        for(int i=start;i<=end;i++)
        {
            if(sb.indexOf(str[i]+"") >=0) continue;
            sb.append(str[i]);
            res.add(sb.toString());
            substrings(str, res, sb, i,i+1);
            sb.deleteCharAt(sb.length()-1);
        }

    public static void main(String[] args)
    {
        String given = "abcd";
        char[] str = given.toCharArray();
        List<String> res = new ArrayList<String>();
        System.out.println("given:" + given + "\n ans:");
        substrings(str, res, new StringBuilder(), 0, str.length-1); 

        for(String s: res)
        {
            System.out.println(s);
        }       

17. Letter Combinations of a Phone Number (Medium) 电话号码的字母组合
Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.
A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

Example: Input: "23"
Output: ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"].
Note: Although the above answer is in lexicographical order, your answer could be in any order you want.
说明: 尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> res = new ArrayList<String>();
        if(digits==null || digits.length() == 0) return res;
        
        HashMap<Character, char[]> hs = new HashMap<Character, char[]>();
        hs.put('2', new char[] {'a','b','c'});
        hs.put('3', new char[] {'d','e','f'});
        hs.put('4', new char[] {'g','h','i'});
        hs.put('5', new char[] {'j','k','l'});
        hs.put('6', new char[] {'m','n','o'});
        hs.put('7', new char[] {'p','q','r','s'});
        hs.put('8', new char[] {'t','u','v'});
        hs.put('9', new char[] {'w','x','y','z'});
        combination(hs, digits, res, new char[digits.length()], 0);
        return res;
    }
    
    public void combination(HashMap<Character, char[]> hs, String digits, List<String> res, char[] l, int index) 
    {        
        if(index==digits.length())
        {
            res.add(new String(l));
            return;
        }
        
        char c = digits.charAt(index);
        char[] alphabet = hs.get(c);
        for(int i=0;i<alphabet.length;i++)
        {
            l[index]= alphabet[i];
            combination(hs, digits, res, l, index+1);
        }

771. Jewels and Stones (Easy) 宝石与石头    
You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.
The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so "a" is considered a different type of stone from "A".
给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。
J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

Example 1: Input: J = "aA", S = "aAAbbbb" Output: 3
Example 2: Input: J = "z", S = "ZZ" Output: 0
Note: S and J will consist of letters and have length at most 50. The characters in J are distinct.
说明: S 和 J 最多含有50个字母。 J 中的字符不重复。

class Solution {
    public int numJewelsInStones(String J, String S) {
        HashSet s = new HashSet();
        for(int i=0;i<J.length();i++)
            s.add(J.charAt(i));
                
        int count = 0;
        for(int i=0;i<S.length();i++)
            if(s.contains(S.charAt(i)))
                count++;
        
        return count;
    }
#### June_02_2019.txt
127. Word Ladder (Medium) 单词接龙
Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:
给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：

Only one letter can be changed at a time. 每次转换只能改变一个字母。
Each transformed word must exist in the word list. 转换过程中的中间单词必须是字典中的单词。
Note that beginWord is not a transformed word.

Note: 说明:
Return 0 if there is no such transformation sequence. 如果不存在这样的转换序列，返回 0。
All words have the same length.所有单词具有相同的长度。
All words contain only lowercase alphabetic characters.所有单词只由小写字母组成。
You may assume no duplicates in the word list. 字典中不存在重复的单词。
You may assume beginWord and endWord are non-empty and are not the same.你可以假设 beginWord 和 endWord 是非空的，且二者不相同。

Example 1: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"] Output: 5
Explanation: As one shortest transformation is (一个最短转换序列是) "hit" -> "hot" -> "dot" -> "dog" -> "cog",
return its length 5. (返回它的长度 5)

Example 2: Input: beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"] , Output: 0
Explanation: The endWord "cog" is not in wordList, therefore no possible transformation. 不在字典中，所以无法进行转换。

class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        Set<String> hs = new HashSet<String>(wordList);
        Queue<String> q = new LinkedList<String>();        
        if(!hs.contains(endWord)) return 0;
        int res = 0;
        q.offer(beginWord);
        
        while(!q.isEmpty())
        {
            for(int i=q.size()-1; i>=0; i--) 
            {
                String word = q.poll();        

                if(word.equals(endWord)) return res+1; // valid answer must contain endWord
                
                for(int j=0;j<word.length();j++)
                {
                    char[] newWord = word.toCharArray();
                    for(char c='a';c <= 'z';c++)
                    {
                        newWord[j]=c;
                        String s = String.valueOf(newWord); // or new String(newWord)                        
                        if(!s.equals(word) && hs.contains(s))
                        {
                            q.offer(s);
                            hs.remove(s);
                        }
            res++;            
        }
        
        return 0; // no valid answer
    }
#### June_03_2019.txt
11. Container With Most Water 盛最多水的容器
Given n non-negative integers a1, a2, ..., an , where each represents a point at coordinate (i, ai). 给定 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). 在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。
Find two lines, which together with x-axis forms a container, such that the container contains the most water. 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

Note: You may not slant the container and n is at least 2. 说明：你不能倾斜容器，且 n 的值至少为 2。
The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. 图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。
In this case, the max area of water (blue section) the container can contain is 49. 在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49
Example: Input: [1,8,6,2,5,4,8,3,7] Output: 49

class Solution {
    public int maxArea(int[] height) {
        int l =0, r = height.length-1;
        int maxWater = 0;        
        
        while(l < r)
        {
            int minHeight = Math.min(height[l],height[r]);
            maxWater= Math.max( (r-l)* minHeight, maxWater); 
            // ** don't make a mistake here. r-l (no space for water ) is correct. not r-l+1 (has space)
            
        // trying to find a bigger height[l], l++ means trying to find a maximum and vice versa. use r-- if trying to find the minimum.
            if(height[l] < height[r])
                l++; 
            else
                r--;
        }
        return maxWater;
    }

42. Trapping Rain Water (Hard) 接雨水
Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. 上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，
In this case, 6 units of rain water (blue section) are being trapped. 在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
Thanks Marcos for contributing this image! 感谢 Marcos 贡献此图。

Example: Input: [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6

class Solution {
    public int trap(int[] height) {        
        int l = 0, r = height.length-1;
        int lmax = 0, rmax = 0;
        int water = 0;
        
        while(l < r)
        { // no need to check l=r. when l=r, no water is contained.

            if(height[l] <= height[r])
            {
                lmax = Math.max(lmax, height[l]);
                water += lmax - height[l]; // add the water of the current height at current position
                l++;
            }
            else
            {
                rmax = Math.max(rmax, height[r]);
                water += rmax - height[r]; 
                r--;
            }
        return water;
    }
#### June_04_2019.txt
167. Two Sum II - Input array is sorted. 两数之和 II - 有序的输入数组
给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。
函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。
说明:返回的下标值（index1 和 index2）不是从零开始的。你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

    public int[] twoSum(int[] numbers, int target) {
        int l = 0, r = numbers.length -1;
        
        while(l<r)
        {
            int x = numbers[l]+numbers[r];
            
            if(x==target) return new int[] {l+1,r+1};
            if(x < target) l++;
            else r--;
        }
        
        return null;
    }

189. Rotate Array (Easy) 旋转数组
给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。
Given an array, rotate the array to the right by k steps, where k is non-negative.
// Time: O(N), Space: O(1)
    public void rotate(int[] nums, int k) {
        k = k % nums.length;
        int p = nums.length - k;
        reverse(nums, 0, p-1); //只在數組區間反轉
        reverse(nums, p, nums.length-1); //
        reverse(nums, 0, nums.length-1); //只在數組區間反轉,用nums.length-1
    }
    
    public void reverse(int[] nums, int l, int r)
    {
        while(l<r)            
        {
            int temp = nums[r];
            nums[r] = nums[l];
            nums[l] = temp;
            l++; r--;
        }

// Time O(N^2), Space: O(1)
    public void rotate(int[] nums, int k) {
        if(nums==null || nums.length==0) return;
        k= k % nums.length;
        
        for(int i=0;i<k;i++)
            for(int j=nums.length-1;j>0;j--)
                swap(nums, j,j-1);
    }
    
    public void swap(int[] nums, int a, int b)
    {
        int t= nums[a];
        nums[a]=nums[b];
        nums[b]=t;
    }

// solution: both space and time are O(N)
    public void rotate(int[] nums, int k) {
        if(nums==null || nums.length==0) return;
        k= k % nums.length;
        int[] res = new int[nums.length];
        for(int i=0;i<k;i++)
        {
            res[i]=nums[nums.length-k+i];
        }
        
        for(int i=k, j=0;i<nums.length;i++)
        {
            res[i]=nums[j++];
        }
        System.arraycopy(res,0,nums,0,nums.length);
    }

7. Reverse Integer 反转整数
Given a 32-bit signed integer, reverse digits of an integer. 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。
Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−231,  231 − 1]. 
假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。
For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.
请根据这个假设，如果反转后整数溢出那么就返回 0。

    public int reverse(int x) {
        int y = Math.abs(x);
        long ans = 0;
        while(y > 0)
        {
            int q = y / 10;
            int r = y % 10;
            ans = ans * 10 + r;
            y = q;
        }
        
        if(x<0) ans=-ans;
        // 別忘了要將long轉型至integer後再傳回.
        return (ans < Integer.MIN_VALUE || ans > Integer.MAX_VALUE) ? 0: (int)ans;
    }

13. Roman to Integer 罗马数字转整数    
Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
I can be placed before V (5) and X (10) to make 4 and 9. I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
    public int romanToInt(String s) {
         if(s==null) return 0;
         HashMap<Character,Integer> m = new HashMap<>();
         m.put('I',1);
         m.put('V',5);
         m.put('X',10);
         m.put('L',50);
         m.put('C',100);
         m.put('D',500);
         m.put('M',1000);
        
        int total = 0;
        for(int i=0;i<s.length();i++)
        {
            char c = s.charAt(i);
            int value = m.get(c);
            boolean negative = false;
                        
            if(s.length() > 1 && i < s.length() - 1) 
            {// length=1 means it's positve. not last one. last one must be positive.
                char next = s.charAt(i+1);
                negative |= (c=='I' && (next == 'V' || next=='X'));
                negative |= (c=='X' && (next == 'L' || next=='C'));
                negative |= (c=='C' && (next == 'D' || next=='M'));
            }
            
            if(negative)
                total-=value;
            else
                total+=value;
        }
        
        return total;
    }
#### June_06_2019.txt
239. Sliding Window Maximum (Hard) 滑动窗口最大值
Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. 
给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
You can only see the k numbers in the window. 你只可以看到在滑动窗口 k 内的数字。
Each time the sliding window moves right by one position. 滑动窗口每次只向右移动一位。
Return the max sliding window. 返回滑动窗口最大值。

Example: Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3 Output: [3,3,5,5,6,7] 
Explanation: 
Window position(滑动窗口的位置)   Max
---------------                 -----
[1  3  -1] -3  5  3  6  7         3
 1 [3  -1  -3] 5  3  6  7         3
 1  3 [-1  -3  5] 3  6  7         5
 1  3  -1 [-3  5  3] 6  7         5
 1  3  -1  -3 [5  3  6] 7         6
 1  3  -1  -3  5 [3  6  7]        7
Note: You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.
你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。
进阶： 你能在线性时间复杂度内解决此题吗？

    // O(nlogk) complexity, since add, pop and remove operation of PriorityQueue cost O(logk) time.
    public int[] maxSlidingWindow(int[] nums, int k) {
        if(nums.length==0) return new int[] {};
        int[] res = new int[nums.length-k+1];
        
         PriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2.compareTo(o1);
            }
        });
        
        for(int i=0;i<k;i++)
             pq.add(nums[i]);
        
        int i = 0;
        for(i = k;i< nums.length;i++)
        {
            res[i-k] = pq.peek();
            pq.remove(nums[i-k]);
            pq.add(nums[i]);
        }
        
        res[i-k] = pq.peek();
        
        return res;             
    }

    // O(kN)
    public int[] maxSlidingWindow_BF(int[] nums, int k) {
        if(nums.length==0) return new int[] {};
        int[] res = new int[nums.length-k+1];
        int i; int max = 0;
        for(i = 0;i<= nums.length-k;i++)
        {
                max = Integer.MIN_VALUE;
            for(int j=i; j < i+k; j++)
                max = Math.max(nums[j], max);
            res[i] = max;
        }
        
        return res;
    }
#### June_07_2019.txt
67. Add Binary (Easy) 二进制求和
Given two binary strings, return their sum (also a binary string).
The input strings are both non-empty and contains only characters 1 or 0.
给定两个二进制字符串，返回他们的和（用二进制表示）。

Input: a = "11", b = "1" Output: "100"
Input: a = "1010", b = "1011" Output: "10101"

    public String addBinary(String a, String b) {
     
        int p = a.length();
        int q = b.length();
        int c = 0;
        StringBuilder sb = new StringBuilder();
        while(p > 0 || q > 0)
        {
            // don't forget to convert numeric char to integer!!
            int x = (p>0) ? (int)(a.charAt(--p)-'0'):0;             
            int y = (q>0) ? (int)(b.charAt(--q)-'0'):0;
            int sum = x + y + c;
            int r = sum % 2;
            c = sum/2;
            sb.insert(0, r);// insert can convert integer to string. risky!! only work for base 2-10
        }
        
        if(c>0) sb.insert(0, c);
        
        return sb.toString();
    }
#### June_09_2019.txt
9. Palindrome Number (Easy)
Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.

Input: 121   Output: true, Input: -121  Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.

Input: 10    Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
Follow up: Coud you solve it without converting the integer to a string?

   public boolean isPalindrome(int x) {
        int temp = Math.abs(x);
        int res = 0;
        while(x > 0)
        {
            int r = x % 10;            
            x = x / 10;
            res = 10 * res + r;
        }

        return (res==temp);
    }

125. Valid Palindrome (Easy)
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
Note: For the purpose of this problem, we define empty string as valid palindrome.
Input: "A man, a plan, a canal: Panama" Output: true
Input: "race a car" Output: false

    public boolean isPalindrome(String s) {        
        int l = 0, r = s.length() - 1;
        
        while (l < r) 
        {
            while (l < r && !Character.isLetterOrDigit(s.charAt(l)))  l++;
            while (l < r && !Character.isLetterOrDigit(s.charAt(r)))  r--;
            
            if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r)))
                return false;
            l++; r--;
        }
        return true;    
    }
    
#### June_10_2019.txt

5. Longest Palindromic Substring (Medium)
Example 1:
Input: "babad"
Output: "bab"
Note: "aba" is also a valid answer.

Input: "cbbd"
Output: "bb"
// O(N^2) solution
    public String longestPalindrome(String s) {
        String max = "";
        
        for(int i=0;i< s.length();i++)
        {
            String s1 = expandFromCenter(s, i, i);
            String s2 = expandFromCenter(s, i, i+1);
            String curMax = (s1.length() > s2.length()) ? s1:s2;
            max = (curMax.length() > max.length()) ? curMax:max;            
        }
        
        return max;
    }
    
    public String expandFromCenter(String s, int l, int r)
    {
        while(l>=0 && r < s.length() && s.charAt(l) == s.charAt(r))
        { 
            l--; r++; 
        }
        
        int len = ((r-1)-(l+1));        
        return s.substring(l+1, r);
    }
#### June_11_2019.txt
2. Add Two Numbers
Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
Explanation: 342 + 465 = 807.
// Time ~ O(Na + Nb), Space ~ O(Na + Nb) 
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        ListNode temp = dummy;
        ListNode p = l1;
        ListNode q = l2;
        int carry = 0;
        
        while(p!=null || q !=null)
        {
            int x = (p==null) ? 0: p.val;
            int y = (q==null) ? 0: q.val;
            int sum = x + y + carry;
            temp.next = new ListNode(sum%10);
            carry = sum/10;
            
            if(p!=null) p=p.next;
            if(q!=null) q=q.next;            
            temp = temp.next;
        }
        
        if(carry > 0) temp.next = new ListNode(carry);
        return dummy.next;
    }

50. Pow(x, n) Medium
Implement pow(x, n), which calculates x raised to the power n (xn).
Example 1:  Input: 2.00000, 10  Output: 1024.00000
Example 2:  Input: 2.10000, 3   Output: 9.26100
Example 3:  Input: 2.00000, -2  Output: 0.25000
Explanation: 2-2 = 1/22 = 1/4 = 0.25
Note: -100.0 < x < 100.0
n is a 32-bit signed integer, within the range [−231, 231 − 1]

https://leetcode.wang/leetCode-50-Pow.html

// Brute Force: O(N) Time where n is the power.
    public double myPow(double x, int n) {
        if(n==0) return 1.0;
        double res = x;
        
        if(n>=0)
        {gir 
            for(int i=1;i<n;i++)
                    res=res*x;
        }
        else if(n < 0)
        {
            n = Math.abs(n);
            for(int i=0;i<=n;i++)
                    res=res/x;            
        }
        
        return res;
    }
#### June_12_2019.txt
43. Multiply Strings (Medium)
Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
Example 1: Input: num1 = "2", num2 = "3" Output: "6"
Example 2: Input: num1 = "123", num2 = "456" Output: "56088"
;The length of both num1 and num2 is < 110.
Both num1 and num2 contain only digits 0-9.
Both num1 and num2 do not contain any leading zero, except the number 0 itself.
You must not use any built-in BigInteger library or convert the inputs to integer directly.

public String multiply(String num1, String num2) {
    int m = num1.length(), n = num2.length();
    int[] pos = new int[m + n];
   
    for(int i = m - 1; i >= 0; i--) {
        for(int j = n - 1; j >= 0; j--) {
            int mul = (num1.charAt(i) - '0') * (num2.charAt(j) - '0'); 
            int p1 = i + j, p2 = i + j + 1;
            int sum = mul + pos[p2];

            pos[p1] += sum / 10;
            pos[p2] = (sum) % 10;
        }
    
    StringBuilder sb = new StringBuilder();
    for(int p : pos) if(!(sb.length() == 0 && p == 0)) sb.append(p);
    return sb.length() == 0 ? "0" : sb.toString();
}

public String multiply2(String num1, String num2) {
	int[] res = new int[num1.length()+num2.length()];
	int k = 0;
	
	for(int i=num1.length()-1;i>=0;i--)
	{
		int x = (int)(num1.charAt(i)-'0');
		int carry = 0;
		int len = k++;  // 0,1,2,3...
		for(int j=num2.length()-1;j>=0;j--)
		{
			if(res[len]>0) carry+=res[len];
			int y = (int)(num2.charAt(j)-'0');
			int product = x*y+carry;
			res[len++] = (product%10);
			carry = product/10;                
		}       
		if(carry>0) res[len]+=carry;      
	}
		
	StringBuilder sb = new StringBuilder();
	for(int i=res.length-1;i>=0;i--)
	{
		if(!(sb.length()==0 && res[i]==0) ) sb.append(res[i]);
	}
	
	return sb.toString();
}
#### June_13_2019.txt
69. Sqrt(x)
Implement int sqrt(int x).
Compute and return the square root of x, where x is guaranteed to be a non-negative integer.
Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned.
Example 1:  Input: 4 Output: 2
Example 2:  Input: 8 Output: 2
Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.

Binary Search: Time ~ O(logN), Space ~ O(1) 
Find a mid and check:
if x / mid < mid, move lower;
if x / mid > mid, move higher;
if x / mid == mid, return mid.
Don't compare x with mid * mid, which may lead to overflow.
Return lo.

    public int mySqrt(int x) {
        if(x<2) return x; // less than 2, which is 1. return 1.
        int l = 1; int r = x; // l not start from 0 to avoid divided by 0
        
        while(l<r)
        {
            int mid= l+(r-l)/2;
            int div = x / mid; //  divide by zero will cause an error
            
            if(div > mid) l=mid+1; // Don't compare x with mid * mid, which may lead to overflow.
            else if(div < mid) r=mid; 
            else // div == x
                return mid; // found
        }
        
        return l-1; // the cloest number
    }
#### June_14_2019.txt
162 Find Peak Element
A peak element is an element that is greater than its neighbors.
Given an input array where num[i] ≠ num[i+1], find a peak element and return its index.
The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.
You may imagine that num[-1] = num[n] = -∞.
For example, in array [1, 2, 3, 1], 3 is a peak element and your function should return the index number 2.
Note:
Your solution should be in logarithmic complexity.

Solution

Binary Search: Time ~ O(logN), Space ~ O(1) 
已知 array 中没有重复元素，所以有四种情况，其中只有 (a) 是 peak：
a)            b)  *        c)       *   d)
     *                 *            *          *     *
*       *                *      *                 *
如果 mid 小于 right (c, d)，则 mid 的右侧一定有 peak；
如果 mid 小于 left (b, d)，则 mid 的左侧一定有 peak；
除上述两种情况外即为 (a)，则 mid 为 peak。
注意：循环条件中必须是 lo <= hi 而不是 lo < hi，因为当 lo = hi = mid 时仍需判断该点是否为 peak。

You may imagine that num[-1] = num[n] = -∞.
So the array must have a peak.
In case b), the peak is num[0]. In case c), the peak is num[n-1],
in case d), num[0] and num[n-1] are peaks.

    public int findPeakElement(int[] nums) {
        int l = 0, r = nums.length-1;
        
        while(l<=r)
        {
          int mid = l+(r-l)/2; //prevent overflow of r+l
        
           if(mid+1 < nums.length && nums[mid] < nums[mid+1]) l=mid+1;
           else if(mid-1 >= 0 && nums[mid-1] > nums[mid]) r=mid-1;
           else return mid;
        }
        
        return -1; // doesn't exist        
    }

34. Find First and Last Position of Element in Sorted Array (Medium)
Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.
Your algorithm's runtime complexity must be in the order of O(log n).
If the target is not found in the array, return [-1, -1].

Example 1:  Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4]
Example 2:  Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1]

https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/

    public int[] searchRange(int[] nums, int target) {
        int l = findFirstOccurrence(nums, target);
        int r = findLastOccurrence(nums, target);
        return new int[] {l,r};
    }
    
    public int findFirstOccurrence(int[] nums, int target) {
        int l = 0, r = nums.length-1;
        int ans = -1;
        while(l<=r)
        {
            int mid = l + (r-l)/2;
            
            if(nums[mid]==target)
            { // check left side to see if there's any target value that's before this one
                ans = mid; // remember last position
                r= mid-1;
            }
            else if(target < nums[mid])
            { // check the left side
                r = mid-1;
            }
            else // nums[mid] is less than target
            { // check the right side
                l = mid+1;
            }                 
        
        return ans;
    }

    public int findLastOccurrence(int[] nums, int target) {
        int l = 0, r = nums.length-1;
        int ans = -1;
        while(l<=r)
        {
            int mid = l + (r-l)/2;
            
            if(nums[mid]==target)
            { // check left side to see if there's any target value that's after this one
                ans = mid; // remember last position
                l = mid+1; // check the right side
            }
            else if(target < nums[mid])
            { // check the left side
                r= mid-1;
            }
            else // nums[mid] is less than target
            { // check the right side
                l = mid+1;
            }                 
        
        return ans;
    }
#### June_15_2019.txt
141. Linked List Cycle Easy
Given a linked list, determine if it has a cycle in it.
To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.
Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: true
Explanation: There is a cycle in the linked list, where tail connects to the second node.

    public boolean hasCycle(ListNode head) {
        ListNode slow = head;
        ListNode fast = head;
        
        while(fast!=null && fast.next!=null)
        {
            slow = slow.next;
            fast = fast.next.next;
            if(slow==fast) return true;
        }
        return false;
    }

    public ListNode detectCycle(ListNode head) {
        if(head==null) return null;
        
        ListNode node = getCycleNode(head);
        if(node==null) return null;
        
        ListNode cur1 = node;
        ListNode cur2 = head;
        while(cur1!=cur2)
        {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        
        return cur1;
    }

142. Linked List Cycle II
Medium

1440

108

Favorite

Share
Given a linked list, return the node where the cycle begins. If there is no cycle, return null.

To represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.

Note: Do not modify the linked list.

Example 1:

Input: head = [3,2,0,-4], pos = 1
Output: tail connects to node index 1
Explanation: There is a cycle in the linked list, where tail connects to the second node.

    public ListNode getCycleNode(ListNode head)
    {
        ListNode slow = head;
        ListNode fast = head;
        
        while(fast!=null && fast.next!=null)
        {
            slow = slow.next;
            fast = fast.next.next;
            if(slow==fast) return slow;
        }
        return null;
    }

#### June_16_2019.txt
14. Longest Common Prefix (Easy)
Write a function to find the longest common prefix string amongst an array of strings.
If there is no common prefix, return an empty string "".
Example 1: Input: ["flower","flow","flight"] Output: "fl"
Example 2: Input: ["dog","racecar","car"] Output: "" 
Explanation: There is no common prefix among the input strings.
Note: All given inputs are in lowercase letters a-z.

    public String longestCommonPrefix(String[] strs) {
        if(strs==null || strs.length==0) return "";
        
        for(int i=1;i<strs.length;i++)
        {
            String prev = strs[i-1], cur  = strs[i];
            int len = Math.min(prev.length(), cur.length()),  j =  0;
            while(j < len && prev.charAt(j)==cur.charAt(j)) j++; 
            if(j==0) return "";            
            strs[i] = strs[i].substring(0, j);
        }
        
        return strs[strs.length-1];
    }

33. Search in Rotated Sorted Array (Medium)
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.
Your algorithm's runtime complexity must be in the order of O(log n).

Example 1: Input: nums = [4,5,6,7,0,1,2], target = 0 Output: 4
Example 2: Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1

    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
                
        while(l<=r)
        {
            int mid = l + (r-l)/ 2;
            
            if(nums[mid]==target) return mid;
            if(nums[mid] < nums[r]) // ascending range is on current right side
            {                
                // check based on current right side, which staisfy binary search condition
              if(nums[mid] < target && target <= nums[r]) l= mid+1;   
              else r = mid -1;
                    
            }
            else // nums[mid] >=  nums[r]. why use >= because we have l <=r.
            {    // ascending range is on the current left side
                // check based on current left side, which staisfy binary search condition
                if(nums[l] <= target && target < nums[mid]) r = mid-1;
                else l = mid + 1;                
            }            
            
        }
        
        return -1;        
    }

81. Search in Rotated Sorted Array II (Medium)
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., [0,0,1,2,2,5,6] might become [2,5,6,0,0,1,2]).
You are given a target value to search. If found in the array return true, otherwise return false.
Example 1:
Input: nums = [2,5,6,0,0,1,2], target = 0 Output: true Example 2:
Input: nums = [2,5,6,0,0,1,2], target = 3 Output: false
Follow up:
This is a follow up problem to Search in Rotated Sorted Array, where nums may contain duplicates.
Would this affect the run-time complexity? How and why?

    public boolean search(int[] nums, int target) {
        int l = 0;
        int r = nums.length-1;
                
        while(l<=r)
        {
            int mid = l + (r-l)/ 2;
            
            if(nums[mid]==target) return true;
            if(nums[mid] < nums[r]) // ascending
            {
              if(nums[mid] < target && target <= nums[r]) l= mid+1;   
              else r = mid -1;
                    
            }
            else if(nums[mid] >  nums[r])
            { 
                if(nums[l] <= target && target < nums[mid]) r = mid-1;
                else l = mid + 1;                
            }            
            else if(nums[mid] == nums[r]) r--; //when it's duplicate
        }
        
        return false;        
    }

328. Odd Even Linked List (Medium)
Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes.
You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity.
Example 1: Input: 1->2->3->4->5->NULL Output: 1->3->5->2->4->NULL
Example 2: Input: 2->1->3->5->6->4->7->NULL Output: 2->3->6->7->1->5->4->NULL
Note:
The relative order inside both the even and odd groups should remain as it was in the input.
The first node is considered odd, the second node even and so on ...

    public ListNode oddEvenList(ListNode head) {
        if(head==null) return null;
        ListNode evenRoot = head.next;
        ListNode cur = head;
        
        while(cur!=null)
        {
            ListNode tempNext = cur.next;            
            if(tempNext!=null) cur.next = cur.next.next;
            cur = tempNext;
        }
        
        ListNode odd = head;
        while(odd!=null)
        {
            if(odd.next==null)
            {
                odd.next = evenRoot;
                break;
            }
            odd = odd.next;
        }
        
        return head;
    }

83. Remove Duplicates from Sorted List (Easy)
Given a sorted linked list, delete all duplicates such that each element appear only once.
Example 1: Input: 1->1->2 Output: 1->2
Example 2: Input: 1->1->2->3->3 Output: 1->2->3

    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = head;
        ListNode prev = null;

        while(cur!=null)
        {            
            if(prev!=null && cur.val == prev.val)         
            {          
                prev.next = cur.next;
                // prev stay the same once current value is removed.
            }
            else 
            {  
                prev = cur;
            }
            cur = cur.next;
        }
        
        return dummy.next;
    }

#### June_17_2019.txt
237. Delete Node in a Linked List (Easy)
Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.
Given linked list -- head = [4,5,1,9], which looks like following:
Example 1: Input: head = [4,5,1,9], node = 5 Output: [4,1,9]
Explanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.

    public void deleteNode(ListNode node) {
        if(node!=null && node.next!=null)
        {
            node.val = node.next.val;
            node.next = node.next.next;
        }

234. Palindrome Linked List (Easy)
Given a singly linked list, determine if it is a palindrome.
Example 1: Input: 1->2 Output: false
Example 2: Input: 1->2->2->1 Output: true
Follow up: Could you do it in O(n) time and O(1) space?

    public boolean isPalindrome(ListNode head) {
        if(head == null || head.next == null) return true;
        
        ListNode middle = null;
         middle =   findMiddle(head);
        ListNode last = reverse(middle);
        return compare(head, last);
        
    }
    
    public ListNode findMiddle(ListNode root)
    {
        if(root==null) return null;
        ListNode slow = root;
        ListNode fast = root;
        
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }
    
    public ListNode reverse(ListNode m){
        ListNode next = null;
        ListNode prev = null;
        ListNode curr = m;
        while(curr != null){
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        return prev;
    }
    
    public boolean compare(ListNode head, ListNode last){
      
       ListNode curr = head;
        while(last != null){
            if(curr.val != last.val) return false;
            curr = curr.next;
            last = last.next;
        }
        return true;
    }

203. Remove Linked List Elements (Easy)
Remove all elements from a linked list of integers that have value val.
Example: Input:  1->2->6->3->4->5->6, val = 6 Output: 1->2->3->4->5

    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode cur = head;
        ListNode prev = dummy;
        
        while(cur!=null)
        {
            if(cur.val==val)
            {
                prev.next = cur.next;
            }
            else
            {
                prev = cur;
            }
            
                cur=cur.next;
        }
        
        return dummy.next;
    }

23. Merge k Sorted Lists (Hard)
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.
Example:
Input: 
[ 1->4->5,
  1->3->4,
  2->6   
]  Output: 1->1->2->3->4->4->5->6

    public ListNode mergeKLists(ListNode[] lists) {
        if(lists==null || lists.length==0) return null;
        
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        PriorityQueue<ListNode> pq = new PriorityQueue<ListNode>(lists.length, new Comparator<ListNode>(){
            @Override
            public int compare(ListNode a, ListNode b)
            {
                return a.val-b.val;
            }
        });
        
        for(ListNode l: lists)
        {
            if(l!=null) pq.add(l);
        }
        
        while(!pq.isEmpty())
        {
            ListNode minimum = pq.poll();
            if(minimum.next!=null) pq.add(minimum.next);
            cur.next = minimum;
            minimum.next = null;
            cur = cur.next;
        }
        
        return dummy.next;
    }
#### June_18_2019.txt
232. Implement Queue using Stacks (Easy)
Implement the following operations of a queue using stacks.
You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).

class MyQueue {
    private Stack<Integer> s1 = new Stack<Integer>();
    private Stack<Integer> s2 = new Stack<Integer>();
    private int front;
    
    /** Initialize your data structure here. */
    public MyQueue() {
        
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        if(s1.isEmpty()) front = x;
        s1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        
        if(!s2.isEmpty()) return s2.pop();        
        while(!s1.isEmpty()) s2.push(s1.pop());        
        return s2.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if(!s2.isEmpty()) return s2.peek();        
        return front;
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return s1.isEmpty() && s2.isEmpty(); 
    }
#### June_19_2019.txt
415. Add Strings (Easy)
Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.
The length of both num1 and num2 is < 5100.
Both num1 and num2 contains only digits 0-9.
Both num1 and num2 does not contain any leading zero.
You must not use any built-in BigInteger library or convert the inputs to integer directly.

    public String addStrings(String num1, String num2) {
     int i = num1.length()-1;
     int j = num2.length()-1;
     int carry = 0;        
     StringBuilder sb = new StringBuilder();
        
      while(i >= 0 || j >= 0)
      {
          int x = (i>=0) ? (int)(num1.charAt(i)-'0'):0;
          int y = (j>=0) ? (int)(num2.charAt(j)-'0'):0;
          int sum = x+y+carry;
          char c = (char)(sum%10+'0');
          sb.insert(0,c);
          carry = sum/10;
          i--;
          j--;
      }
        
        if(carry>0) 
        {
            char c = (char)(carry%10+'0');
            sb.insert(0, c);
        }
        
        return sb.toString();
    }
#### June_29_2019.txt
64. Minimum Path Sum (Medium)
Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
Note: You can only move either down or right at any point in time.
    public int minPathSum(int[][] grid) {
        int[][] dp = new int[grid.length][grid[0].length];
        dp[0][0]= grid[0][0];
        
        for(int i=1;i<grid.length;i++)
            dp[i][0] = dp[i-1][0] + grid[i][0];
                                          
        for(int i=1;i<grid[0].length;i++)
            dp[0][i] = dp[0][i-1] + grid[0][i];
        
        for(int i=1;i<grid.length;i++)
            for(int j=1;j<grid[0].length;j++)
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1]) + grid[i][j];
        return dp[grid.length-1][grid[0].length-1];                                          
    }

    // Time Limit Exceeded
    public int uniquePaths(int m, int n) {
        if(m<=0 && n<=0) return 0;
        if(m==1||n==1) return 1;
        return uniquePaths(m-1,n)+uniquePaths(m,n-1);
    }
    
62. Unique Paths (Medium)
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
How many possible unique paths are there?

    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        dp[0][0] = 1;
        
        for(int i=1;i<m;i++)
            dp[i][0]=dp[i-1][0];
        
        for(int i=1;i<n;i++)
            dp[0][i]=dp[0][i-1];
        
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
            {
                dp[i][j] = dp[i-1][j]+dp[i][j-1];
            }
        return dp[m-1][n-1];
    }

    // Time Limit Exceeded
    public int uniquePaths(int m, int n) {
        if(m<=0 && n<=0) return 0;
        if(m==1||n==1) return 1;
        return uniquePaths(m-1,n)+uniquePaths(m,n-1);
    }

63. Unique Paths II (Medium)
A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
Now consider if some obstacles are added to the grids. How many unique paths would there be?
An obstacle and empty space is marked as 1 and 0 respectively in the grid.
Note: m and n will be at most 100.

    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int[][] dp = obstacleGrid;
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        
        dp[0][0] = (dp[0][0]==1) ? 0 : 1; 
        
        for(int i=1;i < m;i++)
            dp[i][0]= (dp[i][0]==1) ? 0 : dp[i-1][0];   

        for(int i=1;i < n;i++)
            dp[0][i] = (dp[0][i]==1) ? 0: dp[0][i-1];
        
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
                dp[i][j]  = (dp[i][j]==1) ? 0 : dp[i-1][j]+dp[i][j-1];
        
        return dp[m-1][n-1];
    }
#### May_28_2019.txt
46. Permutations
Given a collection of distinct integers, return all possible permutations.

Example:
Input: [1,2,3]
Output:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        permutation(nums , result, new ArrayList<Integer>());
        return result;
    }
    
    public void permutation(int[] nums, List<List<Integer>> result, List<Integer> l)
    {
        if(l.size()==nums.length)
        {
            result.add(new ArrayList(l));
            return;
        }
        
        for(int i=0;i< nums.length;i++)
        {
            if(l.contains(nums[i])) continue; //permutation without repetition
            
            l.add(nums[i]);
            permutation(nums, result, l);
            l.remove(l.size()-1);
        }

47. Permutations II (Medium)
Given a collection of numbers that might contain duplicates, return all possible unique permutations.
Example:
Input: [1,1,2]
Output:
[ [1,1,2],
  [1,2,1],
  [2,1,1]]

class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        permutation(nums, new boolean[nums.length], result, new ArrayList<Integer>(), 0);
        return result;
    }
    
    public void permutation(int[] nums, boolean[] used, List<List<Integer>> result, List<Integer> l, int level)
    {
        if(level==nums.length)
        {
            result.add(new ArrayList<Integer>(l));
            return;            
        }
        
        for(int i=0;i<nums.length;i++)
        {
            if(used[i]) continue;
            
            // prune unwanted branches, skip duplicate nodes
            if(i> 0 && nums[i-1]==nums[i] && !used[i-1]) continue;
            
            used[i]=true;
            l.add(nums[i]);
            permutation(nums, used, result, l, level+1);
            l.remove(l.size()-1);
            used[i]=false;
        }

77. Combinations (Medium)
Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.
Example:
Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        combination(n, k, result, new ArrayList<Integer>(), 1, 0);
        return result;
    }
    
    public void combination(int n, int k, List<List<Integer>> result, List<Integer> l, int start, int level)
    {        
        if(level==k)
        {
            result.add(new ArrayList<Integer>(l));
            return;
        }
        
        for(int i=start;i<=n;i++)
        {
            l.add(i);
            combination(n,k, result, l, i+1, level+1);
            l.remove(l.size()-1);
        }
        
    }

78. Subsets [Medium]
Given a set of distinct integers, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: nums = [1,2,3]
Output:
[
  [3],
  [1],
  [2],
  [1,2,3],
  [1,3],
  [2,3],
  [1,2],
  []
]

class Solution {
    public List<List<Integer>> subsets(int[] nums) {        
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        subsetsHelper(nums, result, new ArrayList<Integer>(), 0);
        return result;
    }
    
    public void subsetsHelper(int[] nums, List<List<Integer>> result, List<Integer> l, int start)
    {        
            result.add(new ArrayList<Integer>(l));
        
        for(int i=start;i<nums.length;i++)
        {
            l.add(nums[i]);
            subsetsHelper(nums, result, l, i+1);
            l.remove(l.size()-1);
        }        
    
}

90. Subsets II (Medium)
Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).
Note: The solution set must not contain duplicate subsets.
Example:
Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

class Solution {
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        List<List<Integer>> result =new ArrayList<List<Integer>>(); 
        Arrays.sort(nums); // sorting is important when there're duplicates
        subsetsHelper(nums, result, new ArrayList<Integer>(), 0);
        return result;
    }
    
    public void subsetsHelper(int[] nums, List<List<Integer>> result, List<Integer> l, int start)
    {
        result.add(new ArrayList<Integer>(l));
        for(int i=start;i<nums.length;i++)
        {
            if(i > start && nums[i-1]==nums[i]  ) continue;             
            l.add(nums[i]);
            subsetsHelper(nums, result, l, i+1);
            l.remove(l.size()-1);
        }

https://leetcode.com/problems/combination-sum/
39. Combination Sum (Medium)
Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
The same repeated number may be chosen from candidates unlimited number of times.
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]

class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {        
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);
        findSum(candidates, result, new ArrayList<Integer>(), target, 0, 0);
        return result;
    }
    
    public void findSum(int[] candidates,List<List<Integer>> result, List<Integer> l, int target, int curSum, int start)
    {
        if(curSum > target) return;
        if(curSum == target)
        {
            result.add(new ArrayList(l));
            return;
        }
        
        for(int i=start;i < candidates.length; i++)
        {
            l.add(candidates[i]);
            findSum(candidates, result, l, target, curSum+candidates[i], i);
            l.remove(l.size()-1);
        }         

#### May_29_2019.txt
40. Combination Sum II (Medium)
Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.
Each number in candidates may only be used once in the combination.
Note:
All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:
Input: candidates = [10,1,2,7,6,1,5], target = 8,
A solution set is:
[
  [1, 7],
  [1, 2, 5],
  [2, 6],
  [1, 1, 6]
]

class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {        
           List<List<Integer>> result = new ArrayList<List<Integer>>();
           Arrays.sort(candidates);
           findSum(candidates, new boolean[candidates.length], target, 0, result, new ArrayList<Integer>(), 0);
           return result; 
    }
    
    public void findSum(int[] candidates, boolean[] used, int target, int curSum, List<List<Integer>> result, List<Integer> l, int start) {
        if(curSum > target) return;
        if(curSum==target)
        {
            result.add(new ArrayList(l));
            return;
        }
        for(int i=start;i<candidates.length;i++)
        {
            if(used[i]) continue;
            
            if(i > 0 && candidates[i]==candidates[i-1]  && !used[i-1]) continue;
            
            used[i]=true;
            l.add(candidates[i]);
            findSum(candidates, used, target, curSum+candidates[i], result, l, i+1);
            l.remove(l.size()-1);
            used[i]=false;
        }
        
    }

#### May_30_2019.txt
216. Combination Sum III (Medium)
Find all possible combinations of k numbers that add up to a number n, given that only numbers from 1 to 9 can be used and each combination should be a unique set of numbers.
Note:
All numbers will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:
Input: k = 3, n = 7
Output: [[1,2,4]]
Example 2:
Input: k = 3, n = 9
Output: [[1,2,6], [1,3,5], [2,3,4]]

class Solution {
    public List<List<Integer>> combinationSum3(int k, int n) {
        int[] nums = new int[] {1,2,3,4,5,6,7,8,9};        
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        Arrays.sort(nums);
        combination(nums, k, n, 0, 0, new ArrayList<Integer>(), result);
        return result;
    }
    
    public void combination(int[] nums, int k, int target, int sum, int start, List<Integer> l, List<List<Integer>> result)
    {
        if(sum > target) return; // add up to a number more than n
        if(l.size() > k) return; // more than k number
        
        if(sum == target && l.size() == k) // k numbers that add up to a number n
        {
            result.add(new ArrayList(l));
            return;
        }
        
        for(int i=start;i < nums.length;i++)
        {                        
            l.add(nums[i]);
            combination(nums, k, target, sum+nums[i],  i+1, l, result); 
            l.remove(l.size()-1);
        }

22. Generate Parentheses (Medium)
Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.
For example, given n = 3, a solution set is:
[
  "((()))",
  "(()())",
  "(())()",
  "()(())",
  "()()()"
]

class Solution {
    public List<String> generateParenthesis(int n) {
        char[] nums = "()".toCharArray();
        List<String> result = new ArrayList<String>();
        combination(nums, new StringBuilder(), result, n,n);
        return result;
    }
    
    public void combination(char[] nums, StringBuilder sb, List<String> result, int left, int right)
    {
        if(left > right) return;
        if(left<0) return;
        if(right<0) return;
        
        if(left==0 && right==0)
        {
            result.add(sb.toString());
            return;
        }
        
        for(int i=0;i<nums.length;i++)
        {            
            sb.append(nums[i]);
            
            if(nums[i]=='(') 
            combination(nums, sb, result, left-1, right);
            else
            combination(nums, sb, result, left, right-1);
                
            sb.deleteCharAt(sb.length()-1);
        }

377. Combination Sum IV (Medium)
Given an integer array with all positive numbers and no duplicates, find the number of possible combinations that add up to a positive integer target.

Example:

nums = [1, 2, 3]
target = 4

The possible combination ways are:
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)

Note that different sequences are counted as different combinations.

Therefore the output is 7.

This problem is a DP problem. 
The hint is (1) it's a permutation/combination. 
(2) the output requirement is a number and not a result list. This indiciates the answers in each recusrive call can be caculated and cached.

// below is not the CORRECT answer but it's ready to optimize using DP.
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] result = new int[2];
        combination(nums, target, 0, new ArrayList<Integer>(), result);
        return result[0];
    }
    
    public void combination(int[] nums, int target, int sum, List<Integer> l, int[] result)
    {
        if(sum > target) return;
        if(sum==target)
        {
            result[0]++;
            return;
        }
        
        for(int i=0;i<nums.length;i++)
        {
            if(nums[i] > target) break;
            
            l.add(nums[i]);
            combination(nums, target, sum+nums[i], l, result);
            l.remove(l.size()-1);
        }
#### May_31_2019.txt
567. Permutation in String (Medium)
Given two strings s1 and s2, write a function to return true if s2 contains the permutation of s1. In other words, one of the first string's permutations is the substring of the second string.
Example 1:
Input: s1 = "ab" s2 = "eidbaooo"
Output: True
Explanation: s2 contains one permutation of s1 ("ba").
Example 2:
Input:s1= "ab" s2 = "eidboaoo"

class Solution { 
// this answer is incorrect due to run time is very bad.
// the correct answer uses silding window algorithm technique

    public boolean checkInclusion(String s1, String s2) {
        if(s2.length() < s1.length()) return false;
        boolean[] used = new boolean[s1.length()];
        return permutation(s1.toCharArray(), used, new StringBuilder(), s2);
    }
    
    public boolean permutation(char[] str,boolean[] used, StringBuilder sb, String s2)
    {
        if(sb.length()==str.length)
            return s2.contains(sb.toString());
        
        for(int i=0;i<str.length;i++)
        {
            if(used[i]) continue;
            used[i]=true;
            sb.append(str[i]);
            if(permutation(str, used, sb, s2)) return true;
            sb.deleteCharAt(sb.length()-1);
            used[i]=false;
        }
        
        return false;
    }
Output: False
 
Note:
The input strings only contain lower case letters.
The length of both given strings is in range [1, 10,000].

