Leetcode Pattern: Sliding Windows for Strings
I strongly believe in learning by doing, so let’s walk through a super simple example to understand how sliding windows work and then come back to leetcode problems. A sliding window approach generally helps us reduce the time complexity for brute force approaches. Given an array of integers of size ‘n’.
Our aim is to calculate the maximum sum possible for ‘k’ consecutive elements in the array. Input as the following: array = {100, 200, 300, 400}. k=2. output is 700. To solve it using brute force means to explore all possible cases. We really don’t care about efficiency at this point but do want correct results. So we could run a nested loop exploring all windows of length k in the given array and pick the max sum. Now notice that having computed the sum of 1st window (size k), in order to get the sum of the next overlapping window we just need to leave out the leftmost item value and add the new (rightmost) item’s value, so we are essentially saving the re-computation of the sum for the non-changing part of the window.
Voila ! we used memory to save time, a very classic trade-off in algorithms and sliding windows are all about this as we’ll see. Time complexity reduced from O(n²) to O(n). Now let’s get to actual leetcode problems.
76. Minimum Window Substring
note : this first problem has been brutally analyzed as this is a tricky concept and forms the basis to solve the next 5. Master this one and try the rest on your own, that would be the best way to learn.
In the previous example the window was of a fixed size, but here we use a window of variable size determined by begin and end markers. A brute force approach would be to iterate through all possible substrings and determine the minimum window which contains all characters of T. How do you see if a substring has all characters of T ? You could use the frequency table of T which stores character to number of occurrences as follows :
So we are basically assuring that every unique character in T exists in B as many times as it exists in T by maintaining a counter. It is fine if there are 4 ‘K’s in T and B has 7 ‘K’s , the table count for ‘K’ would simply go negative, but it goes to 0 at some point before that, proving string B has at least 4 'K’s in it, satisfying the need with respect to “K”, extending the logic to other chars in T if counter = 0, B has all chars in T.
Okay so coming to the sliding window part here, we keep sliding end to the right examining each new character and updating the count in table. As soon as we hit counter = 0, it means we have a valid answer so we try to trim it down removing the unessential characters from the start by sliding begin right. We constantly keep trying to validate / invalidate the string by manipulating counter and table counts.
Take a moment, understand this code. Walk through it on paper for this example:  S = "ADOBE CODE BANC". T = "ABC". Do not worry, the code is just heavily annotated, it is actually very concise.
Intuition : the best substring for the answer would simply be a permutation of T if such a substring exists in S, but otherwise we could have wasteful characters sitting in between the essential characters that make the substring valid as an answer. Our attempt here is to remove such chars without losing the necessary ones. After trimming down as much as possible we resume with sliding end right and repeating the whole process.
Whenever counter = 0 we have a valid candidate for our answer, but we update answer only if it is shorter than previously recorded minimum length answer.
